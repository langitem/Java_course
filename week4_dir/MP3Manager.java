// Emanuel Langit// elangit@my.smccd.edu// CIS 255WJ// MP3Manager.java// class MP3Manager that extends JFrame// Assignment #8// May 17, 2012import java.awt.BorderLayout;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JTextArea;import javax.swing.JTextField;import javax.swing.SwingConstants;public class MP3Manager extends JFrame {	private JPanel mp3Panel;	private JLabel artistNameJLabel;	private JLabel songTitleJLabel;	private JLabel albumNameJLabel;	private JLabel trackLengthJLabel;	private JTextField artistNameJTextField;	private JTextField songTitleJTextField;	private JTextField albumNameJTextField;	private JTextField trackLengthJTextField;	private JButton addMP3JButton;	private JButton findMP3JButton;	private JButton displayMP3sJButton;	private JButton deleteMP3JButton;	private JTextArea mp3DisplayJTextArea;	private FileWriter output;	private Scanner input;	public static final String mp3RecordsTextFile = "MP3Records.txt";	public MP3Manager() {		super( "MP3 Manager Emanuel Langit" );		// build mp3Panel:		mp3Panel = new JPanel();		mp3Panel.setLayout( new GridLayout( 7, 2 ) ); // 6 rows, 2 columns		artistNameJLabel = new JLabel( "Artist Name ", SwingConstants.RIGHT );		mp3Panel.add( artistNameJLabel );		artistNameJTextField = new JTextField( 15 );		mp3Panel.add( artistNameJTextField );		songTitleJLabel = new JLabel( "Song Title ", SwingConstants.RIGHT );		mp3Panel.add( songTitleJLabel );		songTitleJTextField = new JTextField( 15 );		mp3Panel.add( songTitleJTextField );		albumNameJLabel = new JLabel( "Album Name ", SwingConstants.RIGHT );		mp3Panel.add( albumNameJLabel );		albumNameJTextField = new JTextField( 15 );		mp3Panel.add( albumNameJTextField );		trackLengthJLabel = new JLabel ( "Track Length (in seconds) ", SwingConstants.RIGHT );		mp3Panel.add( trackLengthJLabel );		trackLengthJTextField = new JTextField( 15 );		mp3Panel.add( trackLengthJTextField );		addMP3JButton = new JButton( "Add MP3" );		mp3Panel.add( addMP3JButton );		displayMP3sJButton = new JButton( "Display MP3s" );		mp3Panel.add( displayMP3sJButton );		findMP3JButton = new JButton( "Find MP3" );		mp3Panel.add( findMP3JButton );		deleteMP3JButton = new JButton( "Delete MP3" );		mp3Panel.add( deleteMP3JButton );		mp3DisplayJTextArea = new JTextArea();		add( mp3Panel, BorderLayout.NORTH );		add( mp3DisplayJTextArea, BorderLayout.CENTER );		ButtonHandler handler = new ButtonHandler();		addMP3JButton.addActionListener( handler );		displayMP3sJButton.addActionListener( handler );		findMP3JButton.addActionListener( handler );		deleteMP3JButton.addActionListener( handler );	} // end of MP3Manager constructor	// inner class for button event handling	private class ButtonHandler implements ActionListener {		// handle button event		public void actionPerformed( ActionEvent event ) {			String artistNameString = artistNameJTextField.getText();			String songTitleString = songTitleJTextField.getText();			String albumNameString = albumNameJTextField.getText();			String trackLengthString;			trackLengthString = trackLengthJTextField.getText();			if ( event.getActionCommand().contentEquals( "Add MP3" ) ) { // if add mp3 button is pressed, make sure there are no empty fields				if ( ( artistNameString.length() < 1 ) || ( songTitleString.length() < 1 ) || ( albumNameString.length() < 1 ) || ( trackLengthString.length() < 1 ) ) {					String msg = "There are one or more missing fields!";					mp3DisplayJTextArea.setText( msg );									} else {					int trackLengthInteger = 0;					boolean trackLengthNotValid = true;					try {						trackLengthInteger = Integer.parseInt( trackLengthString );						trackLengthNotValid = false;					} catch ( NumberFormatException e ) {						// TODO Auto-generated catch block						mp3DisplayJTextArea.setText( "Track Length field takes integers only!" );						e.printStackTrace();					}										if ( trackLengthInteger < 0 ) {						trackLengthNotValid = true;						mp3DisplayJTextArea.setText( "Track Length cannot be negative!" );					}					if ( !trackLengthNotValid ) { // if track length field is valid						MP3 mp3Sample = new MP3( artistNameString, songTitleString, albumNameString, trackLengthInteger );						String string = mp3Sample.toString();						mp3DisplayJTextArea.setText( string );						addMP3ToFile( mp3Sample );						artistNameJTextField.setText( "" );						songTitleJTextField.setText( "" );						albumNameJTextField.setText( "" );						trackLengthJTextField.setText( "" );					}				} // end of checking if any of the text fields are empty							} else if ( event.getActionCommand().contentEquals( "Display MP3s" ) ) {				// The second button displays all MP3 records from the file sorted by artist name.				displayAllMP3s();							} else if ( event.getActionCommand().contentEquals( "Find MP3" ) ) {				/*				 * The third button will find and display a record if the user enters the song name.  				 * If the song cannot be found then inform the user.				 */				if ( songTitleString.length() < 1 ) { // check that song title field is not empty					mp3DisplayJTextArea.setText( "Song title field is empty!" );				} else {					ArrayList< MP3 > mp3ObjectsArrayList = new ArrayList< MP3 >();					ArrayList< MP3 > mp3ObjectsArrayListSorted = new ArrayList< MP3 >();					mp3ObjectsArrayListSorted = readFile( mp3ObjectsArrayList );										int found = 0;										for ( int i=0; i < mp3ObjectsArrayListSorted.size(); i++ ) {						MP3 currentMP3 = mp3ObjectsArrayListSorted.get( i );												if ( currentMP3.getSong().equalsIgnoreCase( songTitleString ) ) {							mp3DisplayJTextArea.setText( currentMP3.toString() );							++ found;						}												if ( found == 0 )							mp3DisplayJTextArea.setText( "Song not found!" );					} // end of for loop										songTitleJTextField.setText( "" );				}							} else if ( event.getActionCommand().contentEquals( "Delete MP3" ) ) { // The delete button will delete a record from the file based on the song name.				mp3DisplayJTextArea.setText( "" );				if ( songTitleString.length() < 1 ) {					mp3DisplayJTextArea.setText( "Song title field is empty!" );				} else {										// Read the file data into an ArrayList.									ArrayList< MP3 > mp3ObjectsArrayList = new ArrayList< MP3 >();					ArrayList< MP3 > mp3ObjectsArrayListSorted = new ArrayList< MP3 >();					mp3ObjectsArrayListSorted = readFile( mp3ObjectsArrayList );										deleteSong( songTitleString, mp3ObjectsArrayListSorted );				} // end of if delete button was pressed and song title field is valid			} // end of checking which button was pressed		} // end method actionPerformed	} // end private inner class ButtonHandler	public void addMP3ToFile( MP3 mp3Object ) {		String str = String.format( "%s:%s:%s:%s\n", mp3Object.getArtist(), mp3Object.getSong(), mp3Object.getAlbum(), mp3Object.getTrackLength() );		// open file		try		{			output = new FileWriter( mp3RecordsTextFile, true );		} // end try		catch ( IOException ioException )		{			System.err.println( "Error opening file." );		} // end catch		try {			output.write( str );		} catch ( IOException e ) {			// TODO Auto-generated catch block			e.printStackTrace();		}		try // close file		{			if ( output != null )				output.close();		} // end try		catch ( IOException ioException )		{			System.err.println( "Error closing file." );			System.exit( 1 );		} // end catch	} // end of addMP3ToFile method	public void displayAllMP3s() {				String displayString = ""; // string to be displayed in mp3DisplayJTextArea		ArrayList< MP3 > mp3ObjectsArrayList = new ArrayList< MP3 >();		ArrayList< MP3 > mp3ObjectsArrayListSorted = new ArrayList< MP3 >();		mp3ObjectsArrayListSorted = readFile( mp3ObjectsArrayList );				for ( int i=0; i < mp3ObjectsArrayListSorted.size(); i++ )			displayString += String.format( "%s\n", mp3ObjectsArrayListSorted.get( i ).toString() );		mp3DisplayJTextArea.setText( displayString );	} // end of displayAllMP3s method			public ArrayList<MP3> readFile( ArrayList<MP3> mp3ObjectsArrayList ) {		/*		 * 	Method to read text file and store the MP3 objects in an ArrayList.		 * ArrayList containing MP3 objects is returned		 */				ArrayList< String > mp3RecordStringArrayList = new ArrayList< String >();		// open file		try		{			input = new Scanner( new File( mp3RecordsTextFile ) );		} // end try		catch ( FileNotFoundException fileNotFoundException  )		{			System.err.println( "Error opening file." );		}				// read file:		while ( input.hasNextLine() ) {			String mp3RecordString = input.nextLine();			mp3RecordStringArrayList.add( mp3RecordString );			// split line:			String delims = "[:]";			String[] currentMP3 = mp3RecordString.split( delims );			int currentTrackLength = Integer.parseInt( currentMP3[3] );			MP3 currentMP3Object = new MP3( currentMP3[0], currentMP3[1], currentMP3[2], currentTrackLength );			mp3ObjectsArrayList.add( currentMP3Object );		} // end of while loop		// sort mp3ObjectsArrayList using compareTo to compare the MP3 artist names for sorting		Collections.sort( mp3ObjectsArrayList );				input.close();				return mp3ObjectsArrayList;			} // end of readFile method		public void deleteSong( String songTitleString, ArrayList< MP3 > mp3ObjectsArrayListSorted ) {				int found = 0;				for ( int i=0; i < mp3ObjectsArrayListSorted.size(); i++ ) {						// if song entered by user matches a song already in the file			if ( mp3ObjectsArrayListSorted.get( i ).getSong().equalsIgnoreCase( songTitleString ) ) {				String songTitle = mp3ObjectsArrayListSorted.get( i ).getSong();				String deletePrompt = String.format( "Are you sure want to delete\n\"%s\"?", songTitle );				found ++;								// ask user to confirm that they really want to delete the song				if ( ( JOptionPane.showConfirmDialog( null, deletePrompt, "Delete song?", JOptionPane.YES_NO_OPTION ) ) == ( JOptionPane.YES_OPTION ) )					mp3ObjectsArrayListSorted.remove( mp3ObjectsArrayListSorted.get( i ) );							} // end song entered by user matches one in the file					} // end of for loop				songTitleJTextField.setText( "" );		if ( found == 0 ) {			mp3DisplayJTextArea.setText ( "Song not found!" );		}				// open file		try		{			output = new FileWriter( mp3RecordsTextFile, false );		} // end try		catch ( IOException ioException )		{			System.err.println( "Error opening file." );		} // end catch				// write all objects to the file:		for ( int i=0; i < mp3ObjectsArrayListSorted.size(); i++ ) {						String str = String.format( "%s:%s:%s:%s\n", mp3ObjectsArrayListSorted.get(i).getArtist(), mp3ObjectsArrayListSorted.get(i).getSong(), mp3ObjectsArrayListSorted.get(i).getAlbum(), mp3ObjectsArrayListSorted.get(i).getTrackLength() );						try {				output.write( str );			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}					} // end of for loop (writing to the file)				try // close file		{			if ( output != null )				output.close();		} // end try		catch ( IOException ioException )		{			System.err.println( "Error closing file." );			System.exit( 1 );		} // end catch	} // end of deleteSong method} // end of MP3Manager class